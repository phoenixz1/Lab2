import java.net.*;
import java.io.*;
import java.util.*;
import java.lang.*;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;

public class ClientExecutionThread extends Thread {
	public boolean ispaused;
	public int ACKnum;
	public int defaultport = 8002;
	public int tID;	
	public Queue<MazewarPacket> inQueue;
	private Queue<MazewarPacket> outQueue;
	private Map<String, Client> players;
	private String localID;

	// ***Lab3*** map containing connections to all clients
	public  Map<String, SocketInfo> clientsconn;
	
	// ***Lab3*** Socket to communicate to the next client in the ring
	// Socket nextclientSkt = null;


	
	
	
	public ClientExecutionThread (Queue<MazewarPacket> _inQueue, Queue<MazewarPacket> _outQueue, Map<String, Client> clients, String localID,  Map<String, SocketInfo> clientsconn,boolean ispaused, int ACKnum) 
	{
		super("ClientExecutionThread");
		this.inQueue = _inQueue;
		this.outQueue = _outQueue;
		this.players = clients;
		this.localID = localID;
		this.ACKnum = 0;
		this.clientsconn = clientsconn;
		this.ispaused = ispaused;
		this.ACKnum = ACKnum;

		LocalClient.isleader = false;
	}

	public void run() {
		
		// poll inQueue for packets, read packet, executePacket()
MazewarPacket a = new MazewarPacket();
			a.type = 87;
			LocalClient.inQueue.add(a);
		while(true){
			
			if(LocalClient.inQueue.size() != 0) { // Something is in the queue
				System.out.println("Inside run of executetion thread. localid = "+localID+"size "+LocalClient.inQueue.size());			
				MazewarPacket head = LocalClient.inQueue.remove();
				System.out.println("Inside run of executetion thread. localid = "+localID+"; packet type = "+head.type);

				if(head != null) {
					executePacket(head);
				}
			}
		}
    }
	
	public void executePacket(MazewarPacket pkt) {
	
		String cID = pkt.cID;
		Client c = players.get(cID);
		assert(c != null);
		
		if(pkt.type == MazewarPacket.MW_REPLY) { // Client event to process
			KeyEvent e = pkt.event;
			// c.execute_command(e);
			
                        // Up-arrow moves forward.
                        if(e.getKeyCode() == KeyEvent.VK_UP) {
                                c.forward();
                        // Down-arrow moves backward.
                        } else if(e.getKeyCode() == KeyEvent.VK_DOWN) {
                                c.backup();
                        // Left-arrow turns left.
                        } else if(e.getKeyCode() == KeyEvent.VK_LEFT) {
                                c.turnLeft();
                        // Right-arrow turns right.
                        } else if(e.getKeyCode() == KeyEvent.VK_RIGHT) {
                                c.turnRight();
                        // Spacebar fires.
                        } else if(e.getKeyCode() == KeyEvent.VK_SPACE) {
                                c.fire();
                        }
			sendack(cID);
		}
		else if(pkt.type == MazewarPacket.MW_BYE) { // Client wants to quit the game
			// Remove the client from the hash map of players active in the game and from the maze
			try {
				if(LocalClient.isleader) {
				// tell server a client has quit
					LocalClient.outStream.writeObject(pkt);
				}
				if(LocalClient.nextclientSkt.getInetAddress().toString().equals(clientsconn.get(pkt.cID).getInetAddress().toString())) {
				// update the next player
					LocalClient.nextclientSkt = new Socket(pkt.newsocket.getInetAddress(),pkt.newsocket.getPort());
				}
				players.remove(pkt.cID);
				clientsconn.remove(pkt.cID);
				c.maze.removeClient(c);
				sendack(pkt.cID);
			} catch (IOException e) {
				e.printStackTrace();
			}
			
		}
		else if(pkt.type == MazewarPacket.MW_TICK){
			Client clnt = players.get(localID);
			clnt.maze.missiletick();
		}

		else if(pkt.type == MazewarPacket.JOIN_SERV) { //list of clients and leader from naming server
			try {
				clientsconn = pkt.cconns;
	       		     	SocketInfo clientsocket = new SocketInfo(InetAddress.getLocalHost(), defaultport); //local hostname and desired port of self
				if(clientsconn.isEmpty()){
					LocalClient.isleader = true;
					LocalClient.nextclientSkt = null;
					LocalClient.ticker = new MazewarTickerThread(clientsconn,localID);
					LocalClient.ticker.start();
					pkt.type = MazewarPacket.RING_TOKEN;
					LocalClient.inQueue.add(pkt);


				}
				else{
		    			MazewarPacket leaderpkt = new MazewarPacket();
				    	leaderpkt.type = MazewarPacket.CLIENTINFO_REQUEST;
				    	leaderpkt.cID = localID;
		       		     	leaderpkt.newsocket = clientsocket;
		       		     	c = players.get(localID);
		       		     	leaderpkt.StartPoint = c.getPoint();
		       		     	leaderpkt.dir = c.getOrientation().toString();
			    
		       		     	SocketInfo leaderinfo = clientsconn.get(pkt.leader); 
		       			Socket leadersocket = new Socket(leaderinfo.getInetAddress(), leaderinfo.getPort()); // actual socket for connectoin

					ObjectOutputStream outStream = new ObjectOutputStream(leadersocket.getOutputStream());

					outStream.writeObject(leaderpkt);
		
					outStream.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		else if(pkt.type == MazewarPacket.CLIENTINFO_REQUEST){ //only leader receives this packet
			try {
				pkt.type = MazewarPacket.RING_PAUSE; // contains new client info, socket, send those to other clients

				ACKnum = 0; //reset ack received
				sendmcast(pkt);
				c = players.get(pkt.leader);
				clientsconn.put(pkt.cID, pkt.newsocket);
				RemoteClient newClient = new RemoteClient(pkt.cID, 50);
				players.put(pkt.cID, newClient);
				c.maze.addRemoteClient(newClient, pkt.StartPoint, new Direction(pkt.dir));
				
				MazewarPacket outpkt = new MazewarPacket();
				outpkt.type = MazewarPacket.RING_INFO;
				outpkt.clist = players;
				outpkt.cconns = clientsconn;
				outpkt.newsocket = clientsconn.get(pkt.leader);
				//send clientmap, socketmap, ring to new client
				Socket socket = new Socket(pkt.newsocket.getInetAddress(),pkt.newsocket.getPort());
				if(LocalClient.nextclientSkt == null){
				LocalClient.nextclientSkt= socket;
				}
				ObjectInputStream newinStream = new ObjectInputStream(socket.getInputStream());
				ClientReceiverThread receivethread = new ClientReceiverThread(socket, inQueue, newinStream,ispaused, ACKnum); //open a receive thread for the new client
				receivethread.start();

				ObjectOutputStream outStream = new ObjectOutputStream(socket.getOutputStream());
				
				outStream.writeObject(outpkt);

				outStream.close();
				
				int ACKmax = players.size() - 1;
				while(ACKnum < ACKmax);
				outpkt.type =  MazewarPacket.RING_UNPAUSE;
				ACKnum = 0;
				sendmcast(outpkt);
			} catch (IOException e){
				e.printStackTrace();
			}
			
		}
		else if(pkt.type == MazewarPacket.RING_INFO) { // only new client receives this
			try {
				ispaused = true;
				c= players.get(localID);


				LocalClient.nextclientSkt = new Socket(pkt.newsocket.getInetAddress(),pkt.newsocket.getPort());
			
				//creating receive threads
				if (!clientsconn.isEmpty()){
					Iterator i = clientsconn.keySet().iterator();
			
					while (i.hasNext()){
						Object o = i.next();
						assert (o instanceof String);

						SocketInfo s = clientsconn.get((String)o);

						if(!s.getInetAddress().toString().equals(InetAddress.getLocalHost().toString())){
						Socket socket = new Socket(s.getInetAddress(),s.getPort());
						ObjectInputStream newinStream = new ObjectInputStream(socket.getInputStream());
						ClientReceiverThread receivethread = new ClientReceiverThread(socket, inQueue, newinStream,ispaused, ACKnum); 
						receivethread.start();		
						}
					}
				}
				//adding remote clients
				if (!players.isEmpty()){
					Iterator i = pkt.clist.keySet().iterator();
			
					while (i.hasNext()){
						Object o = i.next();
						assert(o instanceof String);

						Client temp = pkt.clist.get((String)o);

						if(!temp.getName().equals(localID)){
							RemoteClient newClient = new RemoteClient(temp.getName(), 50);
							players.put(temp.getName(), newClient);
							c.maze.addRemoteClient(newClient, temp.getPoint(), temp.getOrientation());	
						}
					}
				
				}
				//ACK to leader
				MazewarPacket ackpkt = new MazewarPacket();
				ackpkt.type = MazewarPacket.ACK;
				SocketInfo leaderinfo = clientsconn.get(pkt.leader); 
		   		Socket leadersocket = new Socket(leaderinfo.getInetAddress(), leaderinfo.getPort()); // actual socket for connectoin

				ObjectOutputStream outStream = new ObjectOutputStream(leadersocket.getOutputStream());

				outStream.writeObject(ackpkt);

				outStream.close(); 
				leadersocket.close();
				//pause
				while(ispaused);
			} catch (IOException e) {
				e.printStackTrace();
			}
			
		}
		else if(pkt.type == MazewarPacket.RING_PAUSE) { //non-leader clients get this
			try {
				ispaused = true;
			
				//add new client to all maps
				c = players.get(localID);
				clientsconn.put(pkt.cID, pkt.newsocket);
				RemoteClient newClient = new RemoteClient(pkt.cID, 50);
				players.put(pkt.cID, newClient);
				c.maze.addRemoteClient(newClient, pkt.StartPoint, new Direction(pkt.dir));

				//add new client to ring
				SocketInfo leader = clientsconn.get(pkt.leader);
				if(((LocalClient.nextclientSkt.getInetAddress()).toString()).equals((leader.getInetAddress()).toString())){
					LocalClient.nextclientSkt.close();
					LocalClient.nextclientSkt = new Socket(clientsconn.get(pkt.cID).getInetAddress(),clientsconn.get(pkt.cID).getPort());

				}
			
				//open a receive thread for the new client
				Socket socket = new Socket(pkt.newsocket.getInetAddress(),pkt.newsocket.getPort());
				ObjectInputStream newinStream = new ObjectInputStream(socket.getInputStream());
				ClientReceiverThread receivethread = new ClientReceiverThread(socket, inQueue, newinStream,ispaused,ACKnum); 
				receivethread.start();
			
				//ack to leader
				MazewarPacket ackpkt = new MazewarPacket();
				ackpkt.type = MazewarPacket.ACK;
				SocketInfo leaderinfo = clientsconn.get(pkt.leader); 
		   		Socket leadersocket = new Socket(leaderinfo.getInetAddress(), leaderinfo.getPort()); // actual socket for connectoin

				ObjectOutputStream outStream = new ObjectOutputStream(leadersocket.getOutputStream());

				outStream.writeObject(ackpkt);

		
				outStream.close(); 
				leadersocket.close();
				while(ispaused);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		else if(pkt.type == MazewarPacket.RING_UNPAUSE) {
			System.out.println("unpause in queue");
		}
		else if(pkt.type == MazewarPacket.RING_TOKEN) {
			ACKnum = 0;
			sendmcast();
		}
		else if(pkt.type == MazewarPacket.MW_ELECTION) {
			// start a ticker thread
			LocalClient.ticker = new MazewarTickerThread(clientsconn, localID);
			LocalClient.ticker.start();
			LocalClient.isleader = true;
			
			MazewarPacket np = new MazewarPacket();
			np.cID = localID;
			np.type = MazewarPacket.MW_ELECTION;
			try{
				LocalClient.outStream.writeObject(np);
			} catch(IOException e) {
				e.printStackTrace();
			}
		}
		else { // Other types have no actions
			return;
		}
	}

	public void sendmcast() {
		// Dequeue and multicast the head of outqueue
		// Send RING_TOKEN to next client
	        // NOTE: Do not send the packet to the local client
	        //   - Process the packet immediately after receiving ACK's from all other clients

		MazewarPacket outPacket = outQueue.remove();
		int ACKMax = players.size() - 1;
		Client localClient = players.get(localID);

		try {

			if (!clientsconn.isEmpty()){
				Iterator i = clientsconn.keySet().iterator();
		
				while (i.hasNext()){
					Object o = i.next();
					assert (o instanceof String);

					SocketInfo info = clientsconn.get((String)o);

					// If the socket is from the local client, skip it
					if (((String)o).equals(localID)) {
					    continue;
					}

					Socket mcastSock = new Socket(info.getInetAddress(), info.getPort());

					ObjectOutputStream outStream = new ObjectOutputStream(mcastSock.getOutputStream());
					
					outStream.writeObject(outPacket);

					outStream.close();
					mcastSock.close();
				}
		       }

			// Wait until all ACK's are received
			while(ACKnum < ACKMax) ;

			// All ACK's received; process the key event on the local client
			KeyEvent e = outPacket.event;

			// Up-arrow moves forward.
		        if(e.getKeyCode() == KeyEvent.VK_UP) {
		                localClient.forward();
		        // Down-arrow moves backward.
		        } else if(e.getKeyCode() == KeyEvent.VK_DOWN) {
		                localClient.backup();
		        // Left-arrow turns left.
		        } else if(e.getKeyCode() == KeyEvent.VK_LEFT) {
		                localClient.turnLeft();
		        // Right-arrow turns right.
		        } else if(e.getKeyCode() == KeyEvent.VK_RIGHT) {
		                localClient.turnRight();
		        // Spacebar fires.
		        } else if(e.getKeyCode() == KeyEvent.VK_SPACE) {
		                localClient.fire();
		        }

			if (players.size() > 1) {
				// Event processed; send RING_TOKEN to next client in the ring
				MazewarPacket ringPacket = new MazewarPacket();
				ringPacket.type = MazewarPacket.RING_TOKEN;

				ObjectOutputStream nextOutStream = new ObjectOutputStream(LocalClient.nextclientSkt.getOutputStream());

				nextOutStream.writeObject(ringPacket);


				nextOutStream.close();
			}
			else {
				MazewarPacket tok = new MazewarPacket();
				tok.type = MazewarPacket.RING_TOKEN;
				LocalClient.inQueue.add(tok);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void sendmcast(MazewarPacket pkt) {
		// Special multicast to be used only by leader
		// send RING_STOP and RING_RESUME

		int ACKMax = players.size() - 1;

		try {
			if (!clientsconn.isEmpty()){
				Iterator i = clientsconn.keySet().iterator();
			
				while (i.hasNext()){
					Object o = i.next();
					assert (o instanceof String);

					SocketInfo info = clientsconn.get((String)o);

					// If the socket is from the local client, skip it
					if (((String)o).equals(localID)) {
					    continue;
					}

					Socket mcastSock = new Socket(info.getInetAddress(), info.getPort());

					ObjectOutputStream outStream = new ObjectOutputStream(mcastSock.getOutputStream());

					outStream.writeObject(pkt);


					outStream.close();
					mcastSock.close();
				}

				// Wait until all ACK's are received
				while (ACKnum < ACKMax) ;
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void sendack (String client) {
	    // Create an acknowledgement packet
	    MazewarPacket ackPkt = new MazewarPacket();
	    ackPkt.type = MazewarPacket.ACK;

	    // Create a socket to obtain the info on the destination
	    SocketInfo destInfo = clientsconn.get(client);

	    try {
		    Socket destSock = new Socket(destInfo.getInetAddress(), destInfo.getPort());

		    ObjectOutputStream destOutStream = new ObjectOutputStream(destSock.getOutputStream());

		    destOutStream.writeObject(ackPkt);


		    destOutStream.close();
		    destSock.close();
	    } catch (IOException e) {
		    e.printStackTrace();
	    }
	}

}
